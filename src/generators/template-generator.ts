import { ComponentEvent, ComponentMember, ComponentMeta } from '../types/component.js';
import { BUILT_IN_TYPE_TOKENS } from '../constants/built-in-types.js';

/**
 * Generates the TypeScript code for an Angular wrapper component.
 *
 * @param component - The component metadata
 * @param componentLibraryImport - The npm package name to import component types from
 * @returns The generated TypeScript code
 */
export const generateComponentTemplate = (
  component: ComponentMeta,
  componentLibraryImport: string,
): string => {
  const hasInputs = component.members.length > 0;
  const hasEvents = component.events.length > 0;

  const angularImports = collectAngularImports(hasInputs, hasEvents);
  const lifecycleInterfaces = collectLifecycleInterfaces(hasInputs, hasEvents);
  const typeImports = collectTypeImports(component, componentLibraryImport);

  const inputDeclarations = generateInputDeclarations(component.members);
  const outputDeclarations = generateOutputDeclarations(component.events);
  const propertyAssignments = generatePropertyAssignments(component.members);
  const eventBindings = generateEventBindings(component.events);

  return `/**
 * Auto-generated Angular wrapper for <${component.tagName}>.
 * Source: ${component.sourceModule ?? 'n/a'}
 * DO NOT EDIT - generated by the Custom Elements â†’ Angular generator.
 */
import { ${Array.from(angularImports).sort().join(', ')} } from '@angular/core';
${typeImports ? `\n${typeImports}` : ''}

@Component({
  selector: '${component.selector}',
  standalone: true,
  template: \`<${component.tagName} #host><ng-content></ng-content></${component.tagName}>\`,
  changeDetection: ChangeDetectionStrategy.OnPush,
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
})
export class ${component.className} implements ${lifecycleInterfaces.join(', ')} {
  @ViewChild('host', { static: true }) private readonly host!: ElementRef<HTMLElement>;
${inputDeclarations ? '\n' + inputDeclarations : ''}
${outputDeclarations ? '\n' + outputDeclarations : ''}
  private element?: HTMLElement;
${hasEvents ? '  private teardownFns: Array<() => void> = [];\n' : ''}${
    hasEvents ? '  constructor(private readonly ngZone: NgZone) {}\n' : ''
  }
  ngAfterViewInit(): void {
    this.element = this.host.nativeElement;
${hasEvents ? '    this.setupEventListeners();\n' : ''}${hasInputs ? '    this.syncInputs();\n' : ''}
  }
${hasInputs ? generateOnChangesMethod() : ''}${hasEvents ? generateOnDestroyMethod() : ''}${hasInputs ? generateSyncInputsMethod(propertyAssignments) : ''}${hasEvents ? generateSetupEventListenersMethod(eventBindings) : ''}
}
`;
};

/**
 * Collects the required Angular imports based on component features.
 */
const collectAngularImports = (hasInputs: boolean, hasEvents: boolean): Set<string> => {
  const imports = new Set<string>([
    'AfterViewInit',
    'ChangeDetectionStrategy',
    'Component',
    'CUSTOM_ELEMENTS_SCHEMA',
    'ElementRef',
    'ViewChild',
  ]);

  if (hasInputs) {
    imports.add('Input');
    imports.add('OnChanges');
    imports.add('SimpleChanges');
  }

  if (hasEvents) {
    imports.add('EventEmitter');
    imports.add('NgZone');
    imports.add('OnDestroy');
    imports.add('Output');
  }

  return imports;
};

/**
 * Collects the lifecycle interfaces that the component needs to implement.
 */
const collectLifecycleInterfaces = (hasInputs: boolean, hasEvents: boolean): string[] => {
  const interfaces = ['AfterViewInit'];

  if (hasInputs) {
    interfaces.push('OnChanges');
  }

  if (hasEvents) {
    interfaces.push('OnDestroy');
  }

  return interfaces;
};

/**
 * Collects custom type tokens from component members and events,
 * and generates the import statement for them.
 */
const collectTypeImports = (
  component: ComponentMeta,
  componentLibraryImport: string,
): string => {
  const typeTokens = new Set<string>();

  const collectTypeTokens = (typeText: string) => {
    const matches = typeText.match(/\b[A-Z][A-Za-z0-9_]+\b/g) ?? [];
    matches.forEach((token) => {
      if (!BUILT_IN_TYPE_TOKENS.has(token)) {
        typeTokens.add(token);
      }
    });
  };

  component.members.forEach((member) => collectTypeTokens(member.type));
  component.events.forEach((event) => collectTypeTokens(event.type));

  if (typeTokens.size === 0) {
    return '';
  }

  return `import type { ${Array.from(typeTokens).sort().join(', ')} } from '${componentLibraryImport}';`;
};

/**
 * Generates @Input() property declarations.
 */
const generateInputDeclarations = (members: ComponentMember[]): string => {
  const lines = members.map((member) => {
    const decorator = `  @Input() ${member.name}${member.optional ? '?:' : ':'} ${member.type};`;
    if (member.description) {
      return `  /** ${member.description} */\n${decorator}`;
    }
    return decorator;
  });

  return lines.join('\n');
};

/**
 * Generates @Output() event emitter declarations.
 */
const generateOutputDeclarations = (events: ComponentEvent[]): string => {
  const lines = events.map((event) => {
    const alias = event.eventName !== event.outputName ? `('${event.eventName}') ` : '() ';
    const decorator = `  @Output${alias}${event.outputName} = new EventEmitter<${event.type}>();`;
    if (event.description) {
      return `  /** ${event.description} */\n${decorator}`;
    }
    return decorator;
  });

  return lines.join('\n');
};

/**
 * Generates property assignment statements for syncInputs method.
 */
const generatePropertyAssignments = (members: ComponentMember[]): string => {
  return members.map((member) => `    (element as any).${member.name} = this.${member.name};`).join('\n');
};

/**
 * Generates event binding statements for setupEventListeners method.
 */
const generateEventBindings = (events: ComponentEvent[]): string => {
  return events
    .map(
      (event) =>
        `    this.addEventListener('${event.eventName}', (event) => this.${event.outputName}.emit(event as ${event.type}));`,
    )
    .join('\n');
};

/**
 * Generates the ngOnChanges lifecycle method.
 */
const generateOnChangesMethod = (): string => {
  return `
  ngOnChanges(): void {
    if (!this.element) {
      return;
    }
    this.syncInputs();
  }
`;
};

/**
 * Generates the ngOnDestroy lifecycle method.
 */
const generateOnDestroyMethod = (): string => {
  return `
  ngOnDestroy(): void {
    this.teardownFns.forEach((remove) => remove());
    this.teardownFns = [];
  }
`;
};

/**
 * Generates the private syncInputs method.
 */
const generateSyncInputsMethod = (propertyAssignments: string): string => {
  return `
  private syncInputs(): void {
    if (!this.element) {
      return;
    }
    const element = this.element;
${propertyAssignments}
  }
`;
};

/**
 * Generates the private setupEventListeners method.
 */
const generateSetupEventListenersMethod = (eventBindings: string): string => {
  return `
  private setupEventListeners(): void {
    if (!this.element) {
      return;
    }
${eventBindings}
  }

  private addEventListener(eventName: string, listener: (event: Event) => void): void {
    if (!this.element) {
      return;
    }
    const element = this.element;
    const handler = (event: Event) => {
      this.ngZone.run(() => listener(event));
    };
    element.addEventListener(eventName, handler as EventListener);
    this.teardownFns.push(() => element.removeEventListener(eventName, handler as EventListener));
  }
`;
};
